<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/cmakeforneophytes/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/cmakeforneophytes/" rel="alternate" type="text/html" /><updated>2019-08-20T22:02:48+05:30</updated><id>http://localhost:4000/cmakeforneophytes/feed.xml</id><title type="html">CMake Template Projects</title><subtitle>This work is aimed to help the first-time users of CMake tool to get started fast. This project provides basic introductory documentation, CMake template project for often encountered use-case scenari, etcetera.</subtitle><entry><title type="html">Running Applications Based On Preprocessor Directives</title><link href="http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/07-run-defines-specific-code.html" rel="alternate" type="text/html" title="Running Applications Based On Preprocessor Directives" /><published>2019-08-20T19:53:00+05:30</published><updated>2019-08-20T19:53:00+05:30</updated><id>http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/07-run-defines-specific-code</id><content type="html" xml:base="http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/07-run-defines-specific-code.html">&lt;h1 id=&quot;cmake-support-for-handling-pre-processors-derivatives&quot;&gt;CMake Support for Handling Pre-processors Derivatives&lt;/h1&gt;

&lt;p&gt;Sometimes, as developers, we have situations where in we have to develop source code such that certain sections of it are controllable by use of &lt;em&gt;pre-processor macros&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Obviously these are compile time features that are supported by compilers and hence, having CMake address such issues too is quiet brilliant.&lt;/p&gt;

&lt;h2 id=&quot;whats-the-new-cmake-command-&quot;&gt;What’s the New CMake Command ?&lt;/h2&gt;

&lt;p&gt;One must make use of &lt;code class=&quot;highlighter-rouge&quot;&gt;target_compile_definitions&lt;/code&gt; command while trying to pass on the compile-time directive flags to CMakeLists.txt file.  Note this command is different from the &lt;code class=&quot;highlighter-rouge&quot;&gt;target_compile_options&lt;/code&gt; that we had encountered earlier.&lt;/p&gt;

&lt;p&gt;This command has very similar syntax to other ‘target_xxxxx_xxxxx’ commands.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;target_compile_defintions(
  ${PROJECT_NAME}
  PRIVATE
  ${&amp;lt;list_of_macro&amp;gt;}
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As one could notice, this command too follows a similar syntax to other target_* commands.&lt;/p&gt;

&lt;p&gt;The use of keyword PRIVATE here in this command is to limit the macro visibility to the current project and build only.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt;  Good to mention that the order of writing these command matters.  This command should be mentioned only after the rule for the target of the current project is mentioned.&lt;/p&gt;

&lt;p&gt;Rest all is very similar.&lt;/p&gt;</content><author><name></name></author><category term="demo-example-template" /><summary type="html">CMake Support for Handling Pre-processors Derivatives</summary></entry><entry><title type="html">NuGet Packages &amp;amp; CMake for C++ Programs</title><link href="http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/08-using-nuget.html" rel="alternate" type="text/html" title="NuGet Packages &amp; CMake for C++ Programs" /><published>2019-08-20T19:53:00+05:30</published><updated>2019-08-20T19:53:00+05:30</updated><id>http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/08-using-nuget</id><content type="html" xml:base="http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/08-using-nuget.html">&lt;h1 id=&quot;nuget-integration-with-cmake&quot;&gt;NuGet Integration with CMake&lt;/h1&gt;

&lt;p&gt;Am excited to get this template running, since with this template, we’ll be able to appreciate the support that CMake provides for NuGet package manager.&lt;/p&gt;

&lt;p&gt;The objectives of this demo are the following:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Demonstrate how to automatically &lt;em&gt;install&lt;/em&gt; or &lt;em&gt;restore&lt;/em&gt; NuGet packages hosted on NuGet.org using CMake&lt;/li&gt;
  &lt;li&gt;These NuGet packages would later be used by the template project.  Hence, demonstrate how to locate these NuGet packages on disk&lt;/li&gt;
  &lt;li&gt;Learn a bit about CMake modules, as we would be requiring to create one&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;more-on-nuget&quot;&gt;More on NuGet&lt;/h2&gt;

&lt;p&gt;NuGet is Microsoft-supported way of sharing code.  NuGet.org lists gallery that is used for publicly hosting NuGet packages that could be consumed by other users&lt;/p&gt;

&lt;h3 id=&quot;the-nuget-package-of-interest&quot;&gt;The NuGet Package of Interest&lt;/h3&gt;

&lt;p&gt;I’ll more than happy to demonstrate installing or restoring NuGet Package named ‘Pvs.SoftTools.SystemC.1.0.0’.  This package provides the SystemC include headers and compiled libraries.  This is a C++ library.  The user shall be able to use SystemC features once SystemC NuGet package is successfully integration into the build environment using CMake instructions.&lt;/p&gt;

&lt;p&gt;Link to NuGet Package :  &lt;a href=&quot;https://www.nuget.org/packages/Pvs.SoftTools.SystemC&quot;&gt;My First Experimental SystemC NuGet Package&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; Detailing on creation of NuGet packages is not the goal of this project, and hence, not within the current scope.&lt;/p&gt;

&lt;h2 id=&quot;few-final-strides-before-we-dive-in-&quot;&gt;Few Final Strides Before We Dive In …&lt;/h2&gt;

&lt;p&gt;The current directory structure looks like this&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;08_using_NuGet
|
|..... CMakeLists.txt
|
cmake_modules
|
|..... Find&amp;lt;package_name&amp;gt;.cmake
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once the demo template is executed, one would find new software packages getting installed.  And the newer directory structure would look like this&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;08_using_NuGet
|
|..... CMakeLists.txt
|..... packages.config
|
cmake_modules
|
|..... Find&amp;lt;package_name&amp;gt;.cmake
|
pvs_nuget_packages
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;application-source&quot;&gt;Application Source&lt;/h2&gt;

&lt;p&gt;The demo template uses nuget sources as shown below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Cpp&quot;&gt;#inclue &quot;systemc.h&quot;

int sc_main(int sc_argc, char * sc_argv[])
{
  std::cout &amp;lt;&amp;lt; &quot;\nRunning this SystemC demo example by using Pvs.SoftTools.SystemC NuGet package&quot; &amp;lt;&amp;lt; std::endl;
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As one could notice, I’m using the &lt;em&gt;systemc.h&lt;/em&gt; include header file and the function &lt;em&gt;sc_main&lt;/em&gt; as prescribed by the SystemC library.&lt;/p&gt;

&lt;p&gt;Until and unless, these include headers are not available to the source and SystemC library is not available to link against, compiling the above code snippet just like a normal single source file would report in compilation error(s).&lt;/p&gt;

&lt;p&gt;But, SystemC is an external package, so how does the user download the package ?&lt;/p&gt;

&lt;h2 id=&quot;installing--restoring-nuget-package-pvssofttoolssystemc100&quot;&gt;Installing / Restoring NuGet Package “Pvs.SoftTools.SystemC.1.0.0”&lt;/h2&gt;

&lt;p&gt;User is requested to install the NuGet CLI tool for this activity.  NuGet reads the list of packages to be downloaded and installed by reading &lt;code class=&quot;highlighter-rouge&quot;&gt;packages.config&lt;/code&gt; file.&lt;/p&gt;

&lt;p&gt;The basic template for making entries into &lt;em&gt;packages.config&lt;/em&gt; is as shown below&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;packages&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;package&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Pvs.SoftTools.SystemC&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;version=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0.1.0&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/packages&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With the default settings of the NuGet CLI that is installed, one could make use of &lt;code class=&quot;highlighter-rouge&quot;&gt;nuget-restore&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;nuget-install&lt;/code&gt; command with the above &lt;em&gt;packages.config&lt;/em&gt; as the input to download the packages from NuGet.org to the local disk.&lt;/p&gt;

&lt;p&gt;CMake provides a command &lt;code class=&quot;highlighter-rouge&quot;&gt;find_program&lt;/code&gt; to query if the NuGet CLI is installed&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find_program(NUGET nuget)

if (NOT NUGET)
  message(FATAL_ERROR &quot;&amp;lt;Report Error Message Here&amp;gt;&quot;)
endif()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In order to accomplish this, first we have to make the demo CMakeLists.txt file to point to the directory &lt;em&gt;pvs_nuget_packages&lt;/em&gt; that would contain the installed packages.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set(
  PVS_NUGET_PACKAGES
  ${PROJECT_SOURCE_DIR}/../pvs_nuget_packages
)

file(MAKE_DIRECTORY ${PVS_NUGET_PACKAGES})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The above commands instruct CMake to create an empty directory &lt;em&gt;pvs_nuget_packages&lt;/em&gt; if it doesn’t exist.&lt;/p&gt;

&lt;p&gt;If the NuGet CLI is FOUND, one needs to be aware of the following:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;NuGet CLI uses &lt;em&gt;packages.config&lt;/em&gt; file in order to identify packages to be restored or installed and need to be placed alongside the *&lt;solution_file&gt; (.sln)*.  For this, one may make use of CMake custom command `configure_file`&lt;/solution_file&gt;&lt;/li&gt;
  &lt;li&gt;Restoring or installing the NuGet packages into the directory specified.  For this, user may use &lt;code class=&quot;highlighter-rouge&quot;&gt;add_custom_target&lt;/code&gt; command in order to prepare the command to be run on the command line.  Also, we need to make the solution file dependent on this nuget command execution.  It is only then that the building of the target (executable) will invoke the custom target to be executed and running the custom target, restores the NuGet package onto the local disk at the specified location.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The following listfile rules do the above mentioned.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;add_exectuble(${PROJECT_NAME} ${&amp;lt;list_of_sources&amp;gt;})

if (NUGET)
  # Copies the 'packages.config' file to the directory listing the solution
  configure_file(
    packages.config
    ${CMAKE_SOURCE_DIR}/build/packages.config COPYONLY
  )
  # Adds a custom target 'nuget-restore'
  add_custom_target(
    nuget-restore
    COMMAND NUGET restore ${PROJECT_SOURCE_DIR}/build/${PROJECT_NAME}.sln
    -PackagesDirectory ${PVS_NUGET_PACKAGES}
  )
endif()

add_dependencies(
  ${PROJECT_NAME}
  nuget-restore
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Since, the demo performs out-of-source build, the &lt;em&gt;packages.config&lt;/em&gt; needs to be copied into &lt;em&gt;build&lt;/em&gt; directory.  That is what is being performed by &lt;code class=&quot;highlighter-rouge&quot;&gt;configure_file&lt;/code&gt; command.&lt;/p&gt;

&lt;p&gt;Next, &lt;code class=&quot;highlighter-rouge&quot;&gt;nuget-restore&lt;/code&gt; is the custom target that is to be created and later, solution bulid is make dependent on this custom target.  &lt;code class=&quot;highlighter-rouge&quot;&gt;add_custom_target&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;add_dependencies&lt;/code&gt; are demonstrating that behavior.&lt;/p&gt;

&lt;h2 id=&quot;its-game-time-&quot;&gt;It’s Game Time …&lt;/h2&gt;

&lt;p&gt;Run the executable and one &lt;strong&gt;must&lt;/strong&gt; see the following strings getting printed on the console.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        SystemC 2.3.2-Accellera --- Sep 15 2018 11:52:36
        Copyright (c) 1996-2017 by all Contributors,
        ALL RIGHTS RESERVED

Running this SystemC demo example by using Pvs.SoftTools.SystemC NuGet package
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;yay--&quot;&gt;Yay !! :)&lt;/h4&gt;</content><author><name></name></author><category term="demo-example-template" /><summary type="html">NuGet Integration with CMake</summary></entry><entry><title type="html">Building Static Library &amp;amp; It’s Use</title><link href="http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/05-build-and-link-to-static-library.html" rel="alternate" type="text/html" title="Building Static Library &amp; It's Use" /><published>2019-08-20T19:52:00+05:30</published><updated>2019-08-20T19:52:00+05:30</updated><id>http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/05-build-and-link-to-static-library</id><content type="html" xml:base="http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/05-build-and-link-to-static-library.html">&lt;h1 id=&quot;template-illustrating-creating-a-static-library-and-its-usage&quot;&gt;Template Illustrating Creating a STATIC Library and It’s Usage&lt;/h1&gt;

&lt;p&gt;Let’s revisit the earlier topic on how to build to a STATIC library and have another target (an executable) that requires linking to this static library in order to use the features provided by the library.&lt;/p&gt;

&lt;h2 id=&quot;whats-in-the-example-&quot;&gt;What’s in the example ?&lt;/h2&gt;

&lt;p&gt;This example is a small illustration that show-cases on how one can create static library(ies) and link them all together.  Finally, create an executable that uses them.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;song_characteristics  (TargetType :  STATIC Library)
|..... CMakeLists.txt
|
songs  (TargetType : STATIC Library)
|..... CMakeLists.txt
|
albums  (TargetType : Executable)
|..... CMakeLists.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As shown above, the projects &lt;code class=&quot;highlighter-rouge&quot;&gt;song_characteristics&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;songs&lt;/code&gt; are the two targets that are being built as &lt;em&gt;libraries&lt;/em&gt;.  &lt;code class=&quot;highlighter-rouge&quot;&gt;album&lt;/code&gt; is the project that is consuming these two libraries and creating an executable.&lt;/p&gt;

&lt;h2 id=&quot;points-worth-mentioning&quot;&gt;Points Worth Mentioning&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;song_characteristics&lt;/code&gt; project creates the library by name &lt;em&gt;SongCharacteristics&lt;/em&gt; and also exposes the include files later to be consumed by the &lt;code class=&quot;highlighter-rouge&quot;&gt;song&lt;/code&gt; project.  It is achieved with the two instructions mentioned below:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;add_library(
  ${PROJECT_NAME}
  STATIC
  ${&amp;lt;list_of_sources&amp;gt;}
)

target_include_directories(
  ${PROJECT_NAME}
  PUBLIC
  ${&amp;lt;list_of_include_headers&amp;gt;}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As one can notice above, &lt;em&gt;add_library&lt;/em&gt; creates a target (here, it’s the library) and the type of library that is built is &lt;strong&gt;STATIC&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;All the available options for library types are&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;STATIC : archives of different object-files&lt;/li&gt;
  &lt;li&gt;SHARED : dynamic library that is loaded at run-time&lt;/li&gt;
  &lt;li&gt;MODULE : plugins loaded dynamically using dlopen like functionality&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt;  STATIC library type sets the internal in-built CMake variable &lt;code class=&quot;highlighter-rouge&quot;&gt;BUILD_SHARED_TYPE&lt;/code&gt; to &lt;em&gt;false&lt;/em&gt; or &lt;em&gt;OFF&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Also, one could notice that by mentioning PUBLIC for &lt;em&gt;target_include_directories&lt;/em&gt; command, the current target is trying to use the include headers files both for it’s build as well as later allowing other targets to consume these include headers.&lt;/p&gt;

&lt;h2 id=&quot;listfile-for-creating-song-target-is-exactly-similar-to-song_characteristics-target-creation&quot;&gt;Listfile for Creating &lt;code class=&quot;highlighter-rouge&quot;&gt;song&lt;/code&gt; Target is Exactly Similar to &lt;code class=&quot;highlighter-rouge&quot;&gt;song_characteristics&lt;/code&gt; Target Creation&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Almost similar, but for introduction of one more new CMake command - ‘target_link_libraries’&lt;/em&gt;.  Again, there is another command &lt;code class=&quot;highlighter-rouge&quot;&gt;link_libraries&lt;/code&gt;, but let’s maintain it target specific.&lt;/p&gt;

&lt;p&gt;Yes, you read it right !!&lt;/p&gt;

&lt;p&gt;This new command &lt;em&gt;target_link_libraries&lt;/em&gt; is required to allow linking against the previously created ‘song_characteristics’ target (library).&lt;/p&gt;

&lt;p&gt;Important CMake rules could be seen below&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;add_library(
  ${PROJECT_NAME}
  STATIC
  ${&amp;lt;list_of_sources&amp;gt;}
)

target_link_libraries(
  ${PROJECT_NAME}
  SongCharacteristics
  ${&amp;lt;any_other_set_of_libraries_that_are_needed&amp;gt;}
)

target_include_directories(
  ${PROJECT_NAME}
  PUBLIC
  ${&amp;lt;list_of_current_include_headers_to_be_consumed_by_other_targets&amp;gt;}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I hope that the difference in rules listed over here is pretty intuitive.&lt;/p&gt;

&lt;p&gt;Kindly note that the order of inclusion of these two commands, namely, &lt;em&gt;target_include_directories&lt;/em&gt; and &lt;em&gt;target_link_libraries&lt;/em&gt; should be placed after defining the current target library using &lt;em&gt;add_library&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;finally-create-the-executable-target&quot;&gt;Finally!! Create the Executable Target&lt;/h2&gt;

&lt;p&gt;The final step would be to create a CMakeLists.txt that uses the include headers and libraries from the &lt;code class=&quot;highlighter-rouge&quot;&gt;Song&lt;/code&gt; target project, and creates an &lt;em&gt;executable&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;It is sufficient to list the include headers as PRIVATE since, it is only the current executable target that is going to consume the include headers of ‘album’ project.&lt;/p&gt;

&lt;p&gt;For further details on creating libraries types, refer to this &lt;a href=&quot;https://cmake.org/cmake/help/v3.0/command/add_library.html&quot;&gt;link&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="demo-example-template" /><summary type="html">Template Illustrating Creating a STATIC Library and It’s Usage</summary></entry><entry><title type="html">Generating DLLs and their Use in Applications</title><link href="http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/06-build-and-load-shared-dlls.html" rel="alternate" type="text/html" title="Generating DLLs and their Use in Applications" /><published>2019-08-20T19:52:00+05:30</published><updated>2019-08-20T19:52:00+05:30</updated><id>http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/06-build-and-load-shared-dlls</id><content type="html" xml:base="http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/06-build-and-load-shared-dlls.html">&lt;h1 id=&quot;welcome-back-lets-build-dynamic-link-library-dll&quot;&gt;Welcome Back, Let’s build Dynamic Link Library (DLL)&lt;/h1&gt;

&lt;p&gt;As one might understand, the concept of STATIC libraries and SHARED DLLs is completely different.  Just to mention, explaining the differences between the two libraries is NOT within the scope of this page.&lt;/p&gt;

&lt;p&gt;The object is to get to build DLL target and use (load) them later in an application (an executable).&lt;/p&gt;

&lt;h2 id=&quot;some-information-related-to-dll-library-sources-from-the-current-demo&quot;&gt;Some Information related to DLL Library Sources from the Current Demo&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#ifdef HELPER_ALGO_EXPORTS
#define HELPER_ALGO_EXPORT_DLL __declspec(dllexport)
#else
#define HELPER_ALGO_EXPORT_DLL __declspec(dllimport)
#endif

class HELPER_ALGO_EXPORT_DLL HelperAlgorithms
{
  public:
  
    // Set of Interface APIs that are exported
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;rules-for-creating-dll-and-exporting-an-interface&quot;&gt;Rules for Creating DLL and Exporting an Interface&lt;/h2&gt;

&lt;p&gt;As we could see from the above code snippet, &lt;em&gt;HELPER_ALGO_EXPORTS&lt;/em&gt; control when interface is exported and when it can be imported.&lt;/p&gt;

&lt;p&gt;To create the DLL of HelperAlgorithms, user needs to define &lt;code class=&quot;highlighter-rouge&quot;&gt;HELPER_ALGO_EXPORTS&lt;/code&gt;.  It would enable &lt;code class=&quot;highlighter-rouge&quot;&gt;__declspec(dllexport)&lt;/code&gt; which specifies the compiler to export the interface.&lt;/p&gt;

&lt;p&gt;The following listfile instruction demonstrate how it is done.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;add_library(
  ${PROJECT_NAME}
  SHARED
  ${&amp;lt;list_of_sources&amp;gt;}
)

target_compile_options(
  ${PROJECT_NAME}
  PRIVATE
  -D HELPER_ALGO_EXPORTS
)

target_include_directories(
  ${PROJECT_NAME}
  PUBLIC
  ${&amp;lt;list_of_exported_headers&amp;gt;}
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SHARED&lt;/code&gt; keyword sets the earlier discussed CMake in-built variable &lt;em&gt;BUILD_SHARED_LIBS&lt;/em&gt; is set to &lt;em&gt;true&lt;/em&gt; or &lt;em&gt;ON&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Also, one could easily notice that the CMake command &lt;code class=&quot;highlighter-rouge&quot;&gt;target_compile_options&lt;/code&gt; supports the language constructs such as PUBLIC, SHARED and INTERFACE type.  The basic definition for the usage of these language constructs is the same.&lt;/p&gt;

&lt;p&gt;Within the current example, the compile time option parameter has been set to PRIVATE since this pre-processor directive is required only by the current target (DLL).&lt;/p&gt;

&lt;h2 id=&quot;rules-for-linking-against-dll-and-importing-interfaces&quot;&gt;Rules for Linking against DLL and Importing Interface(s)&lt;/h2&gt;

&lt;p&gt;Rules for linking DLL to the application are no different to what we have witnessed with the earlier example.&lt;/p&gt;

&lt;p&gt;Here, the application that requires to use these interfaces, needs to load this DLL first.  Also, the application MUST NOT TO DEFINE the &lt;em&gt;HELPER_ALGO_EXPORTS&lt;/em&gt; since, it is the one that wants to import these services provided by the DLL.  Compiling the target (application) sources WITHOUT defining the &lt;em&gt;preprocessor&lt;/em&gt; enables &lt;code class=&quot;highlighter-rouge&quot;&gt;__declspec(dllimport)&lt;/code&gt; which indicates to the compiler that the requested interfaces are available within the loaded DLL.&lt;/p&gt;

&lt;p&gt;The only other new CMake command that user would notice in the application listfile is &lt;code class=&quot;highlighter-rouge&quot;&gt;add_custom_command&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Syntax is as shown below&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;add_custom_command(
  TARGET ${PROJECT_NAME} POST_BUILD
  COMMAND ${CMAKE_COMMAND} -E copy
  ${CMAKE_SOURCE_DIR}/build/sources/Debug/HelperAlgorithms.dll
  ${CMAKE_SOURCE_DIR}/build/tests/Debug/
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note that since this is a &lt;em&gt;custom CMake command&lt;/em&gt; that needs to run POST BUILD, hence, it needs to be mentioned only after setting up the target.  In this case, this custom command is used to copy the DLL built at it’s default location and copy it to the location where the final executable is expected to be located.  So, that when application is executed, the application target finds the DLL alongside it.&lt;/p&gt;

&lt;p&gt;That’s it !!&lt;/p&gt;

&lt;p&gt;We haven’t learnt the most efficient of dealing with DLLs on Windows yet, but the actual scope of this demonstration was to showcase the action of SHARED in DLL creation.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;id-definitely-be-interested-in-writing-an-another-small-template-that-highlights-few-new-features-that-have-been-introduced-in-cmake-34-which-have-enabled-the-efficiency-of-dll-creation-on-windows-at-least&quot;&gt;I’d definitely be interested in writing an another small template that highlights few new features that have been introduced in CMake 3.4 which have enabled the efficiency of DLL creation on Windows at-least.&lt;/h3&gt;</content><author><name></name></author><category term="demo-example-template" /><summary type="html">Welcome Back, Let’s build Dynamic Link Library (DLL)</summary></entry><entry><title type="html">Including External Headers</title><link href="http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/03-include-external-headers.html" rel="alternate" type="text/html" title="Including External Headers" /><published>2019-08-20T19:51:00+05:30</published><updated>2019-08-20T19:51:00+05:30</updated><id>http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/03-include-external-headers</id><content type="html" xml:base="http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/03-include-external-headers.html">&lt;h1 id=&quot;creating-targets-that-use-headers-only-external-sources&quot;&gt;Creating Targets that Use Headers ONLY External Sources&lt;/h1&gt;

&lt;p&gt;Within this demo example, we shall see how to incorporate &lt;em&gt;headers only&lt;/em&gt; sources or libraries into our solution.&lt;/p&gt;

&lt;h2 id=&quot;creating-a-dummy-headers-only-utility-file&quot;&gt;Creating a Dummy headers only utility file&lt;/h2&gt;

&lt;p&gt;Let us create &lt;em&gt;Singleton&lt;/em&gt; class for demonstration purposes, place this under a directory other than the solution
directory (as shown below).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;03_include_external_headers
|
|----- CMakeLists.txt
|
common_utilities
|
|------ headers_only
        |
        |----- singleton
               |----- singleton.h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;how-to-include-external-sources-here-headers-only-into-the-solution-listfile-&quot;&gt;How to include external sources (here, HEADERS ONLY) into the solution listfile ?&lt;/h2&gt;

&lt;p&gt;CMake support instruction(s) that allows inclusion of directories that list the sources needed for a target to be
built.  These instructions are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;include_directories&lt;/code&gt;, and&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;target_include_directories&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Both of these instructions allow the current CMakeLists.txt (in this case, &lt;code class=&quot;highlighter-rouge&quot;&gt;03_include_external_headers/CMakeLists.txt&lt;/code&gt;)
to point to the directory and their sub-directories of interest.&lt;/p&gt;

&lt;p&gt;Let’s take out a moment to appreciate the subtle differences between the two commands.&lt;/p&gt;

&lt;p&gt;If the solution-level listfile (here, &lt;code class=&quot;highlighter-rouge&quot;&gt;03_include_external_headers/CMakeLists.txt&lt;/code&gt;) ‘include_directories`
uses this command, then the external sources become available to every other target too.&lt;/p&gt;

&lt;p&gt;Alternatively, if one uses ‘target_include_directories` command, it limits the accessibility of the external
sources only to the defined target of interest.&lt;/p&gt;

&lt;p&gt;Here, within the demo example, the latter CMake command has been used in the following way.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;target_include_directories(
  ${PROJECT_NAME}
  PRIVATE
  &quot;${CMAKE_CURRENT_SOURCE_DIR}/../common_utilities/headers_only/singleton&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here, one thing to notice would be the use of ‘PRIVATE’ keyword.&lt;/p&gt;

&lt;p&gt;The choices that are available to the user are, PUBLIC, PRIVATE and INTERFACE.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;INTERFACE&lt;/strong&gt; :  It means that the sources listed under the &lt;em&gt;include_directories&lt;/em&gt; or &lt;em&gt;target_include_directories&lt;/em&gt;
command shall NOT be consumed by the target being referred, but available for the other sources using this target
This is not the case here, as we trying to IMPORT rather than EXPORT something.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PRIVATE&lt;/strong&gt; :  It means that the sources shall be consumed by the specified target for it’s own build activity.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PUBLIC&lt;/strong&gt; :  Symbolically, &lt;code class=&quot;highlighter-rouge&quot;&gt;PUBLIC := PRIVATE + INTERFACE&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;one-important-thing---order-of-use-of-xxxxinclude_directories-command&quot;&gt;One Important Thing :  Order of Use of xxxxinclude_directories command&lt;/h2&gt;

&lt;p&gt;It is always important to mention the target before one uses the command &lt;em&gt;include_directories&lt;/em&gt; or &lt;em&gt;target_include_directories&lt;/em&gt;.  Only once the target has been defined, one &lt;strong&gt;MUST&lt;/strong&gt; specify or use these include commands.&lt;/p&gt;

&lt;p&gt;Only then the project or solution sources would be able to find these external include headers (sources), rather.&lt;/p&gt;</content><author><name></name></author><category term="demo-example-template" /><summary type="html">Creating Targets that Use Headers ONLY External Sources</summary></entry><entry><title type="html">Test Using CTEST Feature</title><link href="http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/04-testing-using-ctest.html" rel="alternate" type="text/html" title="Test Using CTEST Feature" /><published>2019-08-20T19:51:00+05:30</published><updated>2019-08-20T19:51:00+05:30</updated><id>http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/04-testing-using-ctest</id><content type="html" xml:base="http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/04-testing-using-ctest.html">&lt;h1 id=&quot;testing-using-ctest&quot;&gt;Testing Using CTEST&lt;/h1&gt;

&lt;p&gt;This tutorial is focussed on giving a basic introductory usage of &lt;code class=&quot;highlighter-rouge&quot;&gt;ctest&lt;/code&gt; program, one of the tool features of CMake.&lt;/p&gt;

&lt;p&gt;Though this tutorial objective is to illustrate the use of &lt;code class=&quot;highlighter-rouge&quot;&gt;ctest&lt;/code&gt; features of CMake tool, but it is worth mentioning the following few points beforehand.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;This template also contains instructions related to creation of a target - STATIC library from sources&lt;/li&gt;
  &lt;li&gt;It also lists another target - EXECUTABLE that links against the earlier created STATIC library&lt;/li&gt;
  &lt;li&gt;Finally, the tests are written for testing the EXECUTABLE that explore features of CTEST program&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Points #1 and #2, shall be dealt separately in another template, for the time being, one can ignore them.  One can treat it as there is no separate library that is built.  One can imagine as if the executable is built by a single project that has all the sources present within it.&lt;/p&gt;

&lt;h2 id=&quot;get-started-&quot;&gt;Get started …&lt;/h2&gt;

&lt;p&gt;CMake, again provides us with commands to enable testing features provided by &lt;em&gt;ctest&lt;/em&gt; program.&lt;/p&gt;

&lt;p&gt;There are two ways to doing this.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Either call &lt;code class=&quot;highlighter-rouge&quot;&gt;include(ctest)&lt;/code&gt; in the root directory of the tests, or&lt;/li&gt;
  &lt;li&gt;Call &lt;code class=&quot;highlighter-rouge&quot;&gt;enable_testing()&lt;/code&gt; command before a call to the test directory is made that lists all the tests.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here, I’ve tried to demonstrate this by use of &lt;code class=&quot;highlighter-rouge&quot;&gt;enable_testing()&lt;/code&gt; command.&lt;/p&gt;

&lt;p&gt;Note the order of the instructions presented below&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;add_subdirectory(alu)

enable_testing()
add_subdirectory(alu_tests)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enable_testing()

add_subdirectory(alu)
add_subdirectory(alu_tests)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In both the variants, note that the order in which the instructions are called.
In either case, &lt;code class=&quot;highlighter-rouge&quot;&gt;enable_testing()&lt;/code&gt; is called before adding the directory that lists the tests (&lt;code class=&quot;highlighter-rouge&quot;&gt;alu_tests&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;Both the variants are correct and they allow the detection of tests while the program is executed or run.
Both the commands internally sets the in-built variable &lt;code class=&quot;highlighter-rouge&quot;&gt;BUILD_TESTING&lt;/code&gt; feature to &lt;code class=&quot;highlighter-rouge&quot;&gt;ON&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;we-are-not-done-yet&quot;&gt;We are NOT done yet&lt;/h2&gt;

&lt;p&gt;The above command only does allow only the detection of the tests.  CMake, supports another command &lt;code class=&quot;highlighter-rouge&quot;&gt;add_test&lt;/code&gt; that must be used by the user in order to execute and output the tests run (success/failure) report.&lt;/p&gt;

&lt;p&gt;Hence, where the final executable is built, the user has to make sure that the command &lt;code class=&quot;highlighter-rouge&quot;&gt;add_test&lt;/code&gt; is used along the final target.  Again, note the order of calling &lt;code class=&quot;highlighter-rouge&quot;&gt;add_test&lt;/code&gt; command (after the target is built).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;add_executable(
  ${PROJECT_NAME}
  &amp;lt;sources&amp;gt;
)

add_test(&amp;lt;testName&amp;gt; ${PROJECT_NAME})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That’s it - This is as simple as it can get !&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;add_test&lt;/code&gt; supports few other options as well and all options have not been exercized here.&lt;/p&gt;

&lt;p&gt;Have fun !!&lt;/p&gt;</content><author><name></name></author><category term="demo-example-template" /><summary type="html">Testing Using CTEST</summary></entry><entry><title type="html">Running Basic Hello World Program</title><link href="http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/01-basic-example-hello-world.html" rel="alternate" type="text/html" title="Running Basic Hello World Program" /><published>2019-08-20T19:50:00+05:30</published><updated>2019-08-20T19:50:00+05:30</updated><id>http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/01-basic-example-hello-world</id><content type="html" xml:base="http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/01-basic-example-hello-world.html">&lt;h1 id=&quot;whats-in-this-example-&quot;&gt;What’s In This Example ?&lt;/h1&gt;

&lt;p&gt;This demo illustrates how to build a executable target out of a simple (single) source file.&lt;/p&gt;

&lt;h2 id=&quot;what-does-one-require-&quot;&gt;What does one require ?&lt;/h2&gt;

&lt;p&gt;A simple source (say, hello_world.cpp) that contains just the main function and prints &lt;em&gt;something&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;int main (int argc, char * argv[])
{
    std::cout &amp;lt;&amp;lt; &quot;\nHello World !!!&quot; &amp;lt;&amp;lt; std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;how-to-build-an-executable-out-of-this-source-&quot;&gt;How to build an executable out of this source ?&lt;/h2&gt;

&lt;p&gt;Well, there could lots of variables that one could setup in-order to achieve this objective.
One of the ways to accomplish that is presented below&lt;/p&gt;

&lt;p&gt;As mentioned in the earlier template, start with mentioning the minimum required CMake tool version.&lt;/p&gt;

&lt;p&gt;Next immediate need would be to specify the various attributes for the project.
These would be, name of the project, project versioning, language(s) supported by the project, etc. 
Below is an illustration.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;project (
  HelloWorld
  LANGUAGES CXX
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For this demo example, the project name has been specified as &lt;strong&gt;HelloWorld&lt;/strong&gt;.  Notice the use of &lt;em&gt;project&lt;/em&gt; CMake language construct.
The sources listed within this project are Cpp sources.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; User could use &lt;strong&gt;PROJECT_NAME&lt;/strong&gt; variable to query the &lt;em&gt;name of the project&lt;/em&gt; in the later part of the listfile.&lt;/p&gt;

&lt;p&gt;Moving on.. Now, let’s start listing the source files.
User could make multiple ways to list the source files.  One of them is to accumulate all the sources under a single variable by making use of &lt;strong&gt;set&lt;/strong&gt; CMake command.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set(
  SOURCES
  hello_world.cpp
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The final thing that the user is required to mention is the target.
For a given CMake project, a target could either be a &lt;em&gt;library&lt;/em&gt; or an &lt;em&gt;executable&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Here, the objective of this example is to create an executable out of a simple CPP source file.  Hence, the target becomes the &lt;strong&gt;executable&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;So, the final pending instruction is creating the executable.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;add_executable(
  ${PROJECT_NAME}
  ${SOURCES}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Kindly pay attention that here, the target (executable) name is the same as the project solution name.&lt;/p&gt;

&lt;p&gt;There is &lt;em&gt;python script&lt;/em&gt; provided which could be used for cleaning, configuring, building, and running the built executable.&lt;/p&gt;

&lt;p&gt;The command-line arguments for the above Python script are &lt;strong&gt;clean&lt;/strong&gt;, &lt;strong&gt;configure&lt;/strong&gt;, &lt;strong&gt;build&lt;/strong&gt; and &lt;strong&gt;run&lt;/strong&gt;, respectively.&lt;/p&gt;

&lt;p&gt;After running the executable, one should be able to view the below string printed on the standard output console.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hello World !!!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Congratulations !  :)&lt;/p&gt;

&lt;p&gt;You have just finished executing your first CPP program using &lt;em&gt;CMake&lt;/em&gt;.&lt;/p&gt;</content><author><name></name></author><category term="demo-example-template" /><summary type="html">What’s In This Example ?</summary></entry><entry><title type="html">Workspace Containing Multiple Programs</title><link href="http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/02-multi-project-solution.html" rel="alternate" type="text/html" title="Workspace Containing Multiple Programs" /><published>2019-08-20T19:50:00+05:30</published><updated>2019-08-20T19:50:00+05:30</updated><id>http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/02-multi-project-solution</id><content type="html" xml:base="http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/02-multi-project-solution.html">&lt;h1 id=&quot;multi-project-solution-&quot;&gt;Multi-Project Solution ?&lt;/h1&gt;

&lt;p&gt;A solution is a collection of one or more than one project(s).  It could be collection of various independent source code components that together create a targets (libraries or executables).  It could also contain test projects testing the targets.  On Windows, if one is using MSVC IDE, they can map filename ending in &lt;code class=&quot;highlighter-rouge&quot;&gt;.sln&lt;/code&gt; as the &lt;code class=&quot;highlighter-rouge&quot;&gt;solutions&lt;/code&gt; file.&lt;/p&gt;

&lt;h2 id=&quot;what-this-demo-is-all-about-then-&quot;&gt;What this demo is all about then ?&lt;/h2&gt;

&lt;p&gt;Within this example, the intent is to demonstrate on how to organize the source code and create multiple targets, specifically, focus would be to create multiple executables within the same solution.&lt;/p&gt;

&lt;h2 id=&quot;source-code-organization&quot;&gt;Source Code Organization&lt;/h2&gt;

&lt;p&gt;Let’s focus on out-of-source build.  Start thinking about two (independent) projects, for instance, name them &lt;code class=&quot;highlighter-rouge&quot;&gt;first_project&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;second_project&lt;/code&gt;.  Let these two project create two different targets (executables).&lt;/p&gt;

&lt;h3 id=&quot;how-do-we-perform-this-build-activity-just-with-the-help-of-one-cmake-listfile-&quot;&gt;How do we perform this build activity just with the help of &lt;em&gt;one&lt;/em&gt; CMake listfile ?&lt;/h3&gt;

&lt;p&gt;Well, it is possible to achieve this objective, but let me illustrate one of the ways with one top-level listfile and multiple subdirectory listfiles.  Consider this folder organization.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;02_multi_project_solution
|
|------ first_project
|       |----- main.cpp
|       |----- CMakeLists.txt
|
|------ second_project
|       |----- main.cpp
|       |----- CMakeLists.txt
|
|------ CMakeLists.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As one could see, there is a top-level CMakeLists.txt file along with two other listfiles, within the two different source directories, namely, &lt;code class=&quot;highlighter-rouge&quot;&gt;first_project/CMakeLists.txt&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;second_project/CMakeLists.txt&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;what-is-the-difference-between-these-listfiles-present-at-different-hierarchies-&quot;&gt;What is the difference between these listfiles present at different hierarchies ?&lt;/h2&gt;

&lt;p&gt;While the top-level CMakeLists.txt file has to deal with specifying the solution level properties, locating the child CMakeLists.txt files, the sub-project CMakeLists.txt contains instructions those are similar to that we’ve already seen with template &lt;code class=&quot;highlighter-rouge&quot;&gt;01_basic_example_hello_world&lt;/code&gt;.  Here too, the responsibility of the project specific CMakeLists.txt is to build their respective targets (executables).&lt;/p&gt;

&lt;h2 id=&quot;how-does-top-level-solution-level-listfile-find-the-child-level-project-level-listfiles-&quot;&gt;How does top-level (solution-level) listfile find the child-level (project-level) listfiles ?&lt;/h2&gt;

&lt;p&gt;When CMake tool is executed on the parent listfile, the top-level CMakeLists.txt behaves like the parent for all the sources and listfiles within the &lt;code class=&quot;highlighter-rouge&quot;&gt;first_project&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;second_project&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;CMake language construct provides the user with the command &lt;code class=&quot;highlighter-rouge&quot;&gt;add_subdirectory&lt;/code&gt; to find other listfiles located within the sub-directories&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;add_subdirectory(first_directory)
add_subdirectory(second_directory)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is all what is needed to be done at the parent-level listfile.&lt;/p&gt;

&lt;p&gt;The creation of the targets is the individual responsibility of the listfiles present within the sub-directories.&lt;/p&gt;

&lt;p&gt;Visit the demo example ‘02_multi_project_solution` for the complete sources.&lt;/p&gt;</content><author><name></name></author><category term="demo-example-template" /><summary type="html">Multi-Project Solution ?</summary></entry><entry><title type="html">Displaying System Information</title><link href="http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/00-system-information.html" rel="alternate" type="text/html" title="Displaying System Information" /><published>2019-08-20T19:49:00+05:30</published><updated>2019-08-20T19:49:00+05:30</updated><id>http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/00-system-information</id><content type="html" xml:base="http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/00-system-information.html">&lt;h1 id=&quot;example-illustrating-capturing-system-information-using-cmake&quot;&gt;Example Illustrating Capturing System Information Using CMake&lt;/h1&gt;

&lt;p&gt;This demo example lists no source C++ source code.  This demo example just lists a single CMakeLists.txt file.  As you might have noticed within the ‘Introductory Slides for CMake’, for generating the scripts, the first CMake stuff that is required is this &lt;em&gt;listfile&lt;/em&gt;, namely, &lt;em&gt;CMakeLists.txt&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Let’s create a &lt;em&gt;listfile&lt;/em&gt; within the project directory.&lt;/p&gt;

&lt;h2 id=&quot;specify-recommended-version-of-cmake-tool-for-your-build-activity&quot;&gt;Specify recommended version of CMake tool for your build activity&lt;/h2&gt;

&lt;p&gt;The recommended CMake instruction that must go into any CMakeLists.txt at the beginning is shown below.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmake_minimum_required(VERSION &amp;lt;version_number&amp;gt; &amp;lt;optional_error_handling&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;It is intuitive to understand the arguments that are needed to provided in order to let the build system confirm to a specific version of CMake and above.&lt;/p&gt;

&lt;h2 id=&quot;what-if-cmake-listfile-required-version-is-not-met-&quot;&gt;What if CMake listfile required version is not met ?&lt;/h2&gt;

&lt;p&gt;Let’s verify CMake version on my current system which I’ve this infra-structure in place.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\&amp;gt;cmake --version
cmake version 3.14.0

CMake suite maintained and supported by Kitware (kitware.com/cmake).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Let’s try to modify the minimum version of CMake required from 3.14.0 to (hypothetical) 4.0.0 (not available or not yet installed) and observe the behavior on the above command execution.&lt;/p&gt;
&lt;div class=&quot;language-cmake highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cmake_minimum_required&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;VERSION 4.0 FATAL_ERROR&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; &lt;em&gt;FATAL_ERROR&lt;/em&gt; option is ignored by CMake version 2.6 and higher.&lt;/p&gt;

&lt;p&gt;Now, observe what happens when the CMake version is not met and how cmake reports this.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PS xxxxxxxxxxx\learn-cmake\cmake_for_cpp\00_system_information&amp;gt; cmake .
-- Building for: Visual Studio 15 2017
CMake Error at CMakeLists.txt:1 (cmake_minimum_required):
  CMake 4.0 or higher is required.  You are running version 3.14.0


-- Configuring incomplete, errors occurred!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;query-system-information&quot;&gt;Query System Information&lt;/h2&gt;
&lt;p&gt;CMake has support for lots of in-built variables that provide the system information to the user.&lt;/p&gt;

&lt;p&gt;Few of them have been demonstrated as a part of this &lt;a href=&quot;/cmake_for_cpp/00_system_information/CMakeLists.txt&quot;&gt;demo&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;cmake-support-of-variables-describing-system-and-providing-information&quot;&gt;CMake Support of Variables describing System and providing Information&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html#id4&quot;&gt;Describing System&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html#variables-that-provide-information&quot;&gt;Providing Information&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt;
  For running this sample, no in-source/out-of-source build(s) are required since we are not building project/solution from any source.  This is an empty solution.&lt;/p&gt;</content><author><name></name></author><category term="demo-example-template" /><summary type="html">Example Illustrating Capturing System Information Using CMake</summary></entry><entry><title type="html">Demo-Examples</title><link href="http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/demo-examples.html" rel="alternate" type="text/html" title="Demo-Examples" /><published>2019-08-20T19:16:00+05:30</published><updated>2019-08-20T19:16:00+05:30</updated><id>http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/demo-examples</id><content type="html" xml:base="http://localhost:4000/cmakeforneophytes/demo-example-template/2019/08/20/demo-examples.html">&lt;p&gt;Here is the list of demo examples current available for the user to explore capabilities of CMake build generator&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Demo Example-1
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;/cmakeforneophytes/demo-example-template/2019/08/20/00-system-information.html&quot;&gt;00_system_information&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Demo Example-2
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;/cmakeforneophytes/demo-example-template/2019/08/20/01-basic-example-hello-world.html&quot;&gt;01_basic_example_hello_world&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Demo Example-3
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;/cmakeforneophytes/demo-example-template/2019/08/20/02-multi-project-solution.html&quot;&gt;02_multi_project_solution&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Demo Example-4
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;/cmakeforneophytes/demo-example-template/2019/08/20/03-include-external-headers.html&quot;&gt;03_include_external_headers&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Demo Example-5
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;/cmakeforneophytes/demo-example-template/2019/08/20/04-testing-using-ctest.html&quot;&gt;04_testing_using_ctest&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Demo Example-6
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;/cmakeforneophytes/demo-example-template/2019/08/20/05-build-and-link-to-static-library.html&quot;&gt;05_bulid_and_link_to_static_library&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Demo Example-7
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;/cmakeforneophytes/demo-example-template/2019/08/20/06-build-and-load-shared-dlls.html&quot;&gt;06_build_and_load_shared_dlls&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Demo Example-8
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;/cmakeforneophytes/demo-example-template/2019/08/20/07-run-defines-specific-code.html&quot;&gt;07_run_defines_specific_code&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Demo Example-9
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;/cmakeforneophytes/demo-example-template/2019/08/20/08-using-nuget.html&quot;&gt;08_using_NuGet&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="demo-example-template" /><summary type="html">Here is the list of demo examples current available for the user to explore capabilities of CMake build generator</summary></entry></feed>